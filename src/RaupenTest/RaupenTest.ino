#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

/** Motor 1 Einstellungen */
#define SPEED_PIN_MOTOR_A 6  
#define DIR_1_MOTOR_A 7
#define DIR_2_MOTOR_A 5
int motorSpeedA = 0;

/** Motor 3 Einstellungen */
#define SPEED_PIN_MOTOR_B 3   
#define DIR_1_MOTOR_B 4
#define DIR_2_MOTOR_B 2
int motorSpeedB = 0;

/** radio und joystick */
RF24 radio(9,10); // CE, CSN
const byte address[6] = "00001";
char receivedData[32] = "";
int  xAxis, yAxis;
int joystick[2]; 

/** Funktion um den Motor zu stoppen */
void motorStop(){
    digitalWrite(DIR_1_MOTOR_A, LOW);
    digitalWrite(DIR_2_MOTOR_A, LOW);
    digitalWrite(DIR_1_MOTOR_B, LOW);
    digitalWrite(DIR_2_MOTOR_B, LOW);

    analogWrite(SPEED_PIN_MOTOR_A, 0);
    analogWrite(SPEED_PIN_MOTOR_B, 0);
}

 
void setup() {
  // als erste mal die Serielle Schnittstelle dir braucht evtl einen Moment.
  Serial.begin(9600);

  // pin richtunge wählen
  pinMode(SPEED_PIN_MOTOR_A, OUTPUT);
  pinMode(SPEED_PIN_MOTOR_B, OUTPUT);
  pinMode(DIR_1_MOTOR_A, OUTPUT);
  pinMode(DIR_2_MOTOR_A, OUTPUT);
  pinMode(DIR_1_MOTOR_B, OUTPUT);
  pinMode(DIR_2_MOTOR_B, OUTPUT);
 
  radio.begin();
  radio.openReadingPipe(0, address);
  radio.setPALevel(RF24_PA_MAX);
  radio.startListening();
  
  motorStop();
}


void loop() {

  // check RF input
  if (radio.available()) {   // If the NRF240L01 module received data
     
      radio.read( joystick, sizeof(joystick) );
 
    radio.read(&receivedData, sizeof(receivedData));
    yAxis = joystick[0];
    xAxis = joystick[1];
    
    Serial.println(yAxis);
    Serial.println(xAxis);
 
  }

  // Joystick nach unten? gedrückt (evtl unten und oben tauschen)
  // mitte scheint irgendwo bei 510 zu liegen einwenig puffer damit das Teil nicht gleich loshüpft.
  if (yAxis < 470) {

    // motorA richtung setzten nach vorne
    digitalWrite(DIR_1_MOTOR_A, HIGH);
    digitalWrite(DIR_2_MOTOR_A, LOW);

    // motorB nach vorne
    digitalWrite(DIR_1_MOTOR_B, HIGH);
    digitalWrite(DIR_2_MOTOR_B, LOW);

    // errechne grundgeschwindigkeit
    motorSpeedA = map(yAxis, 470, 0, 0, 255);
    motorSpeedB = map(yAxis, 470, 0, 0, 255);
  
  }else if (yAxis > 550) { // nach unten gedrück 

    // motor a richtung rückwärts
    digitalWrite(DIR_1_MOTOR_A, LOW);
    digitalWrite(DIR_2_MOTOR_A, HIGH);

    // motor b richtung rückwärts
    digitalWrite(DIR_1_MOTOR_B, LOW);
    digitalWrite(DIR_2_MOTOR_B, HIGH);

    // errechne grundgeschwindigkeit
    motorSpeedA = map(yAxis, 550, 1023, 0, 255);
    motorSpeedB = map(yAxis, 550, 1023, 0, 255);
  
  } else { // ein wert zwischen 470 und 550 dann geschwindigkeit auf 0 setzen
    motorSpeedA = 0;
    motorSpeedB = 0;
  }

  // nun mal recht links auswerten
  // links? 
   if (xAxis < 470) {
    
    // wert de joysticks auf einen wert zwischen 0(stop) und 255 (max geschwindigkeit) mappen 
    int xMapped = map(xAxis, 470, 0, 0, 255);
    
    motorSpeedA = motorSpeedA - xMapped; // motor a langsamer
    motorSpeedB = motorSpeedB + xMapped; // mtor  b schneller fahre nach links???

    
    // Confine the range from 0 to 255
    if (motorSpeedA < 0) { // neg speed abschneiden und 0 en
      motorSpeedA = 0;
    }
    if (motorSpeedB > 255) { // max speed deckeln
      motorSpeedB = 255;
    }
  }
  if (xAxis > 550) {
    
    int xMapped = map(xAxis, 550, 1023, 0, 255);
    
    motorSpeedA = motorSpeedA + xMapped;
    motorSpeedB = motorSpeedB - xMapped;
    
    if (motorSpeedA > 255) { // max speed deckeln
      motorSpeedA = 255;
    }
    if (motorSpeedB < 0) {  // neg speed abschneiden und 0 en
      motorSpeedB = 0;
    }
  }

  // Geschwindigkeiten zwischen 0 und 70 auf 0 setzten (wahrscheinlich zu wenig für die Motoren)
  if (motorSpeedA < 70) { 
    motorSpeedA = 0;
  }
  if (motorSpeedB < 70) {
    motorSpeedB = 0;
  }

  // setze die geschwindigkeit der Motoren
  analogWrite(SPEED_PIN_MOTOR_A, motorSpeedA); // Send PWM signal to motor A
  analogWrite(SPEED_PIN_MOTOR_B, motorSpeedB); // Send PWM signal to motor B

}
